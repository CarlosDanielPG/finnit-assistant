// -----------------------------------------------------
// Prisma Schema — Finnit Assistant (MVP)
// DB: PostgreSQL
// -----------------------------------------------------

generator client {
  provider = "prisma-client-js"
  output   = "../generated/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ---------------------- Enums ------------------------

enum AccountType {
  cash
  debit
  credit
  savings
  ewallet
}

enum TransactionType {
  income
  expense
  transfer
  adjustment
}

enum TransactionSource {
  manual
  imported
  ocr
  sms
}

enum NotificationType {
  budget
  debt_due
  recurring
  summary
}

enum NotificationStatus {
  scheduled
  sent
  read
  dismissed
}

enum BankProvider {
  belvo
  paybook
  other
}

enum BankConnectionStatus {
  active
  revoked
  error
}

enum ReconciliationItemType {
  balance
  transaction
}

enum ReconciliationState {
  confirmed
  corrected
  ignored
}

enum DebtKind {
  loan
  card
  other
}

enum RecurringFrequency {
  daily
  weekly
  monthly
  custom
}

// ---------------------- Models -----------------------

model User {
  id           String   @id @default(uuid())
  name         String
  email        String   @unique
  passwordHash String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  accounts        Account[]
  categories      Category[]
  transactions    Transaction[]
  recurringRules  RecurringRule[]
  budgets         Budget[]
  goals           Goal[]
  notifications   Notification[]
  bankConnections BankConnection[]
  reconciliations ReconciliationSession[]
  tags            Tag[]
  Debt            Debt[]
}

model Account {
  id             String      @id @default(uuid())
  userId         String
  type           AccountType
  name           String
  currency       String      @db.VarChar(3)
  balanceCurrent Decimal     @db.Decimal(18, 2)
  metadata       Json?
  archived       Boolean     @default(false)
  createdAt      DateTime    @default(now())
  updatedAt      DateTime    @updatedAt

  user                User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  creditCardTerms     CreditCardTerms?
  transactions        Transaction[]
  linkedAccounts      LinkedAccount[]
  reconciliationItems ReconciliationItem[]
  debtsLinked         Debt[]               @relation("debt_linked_account")
  RecurringRule       RecurringRule[]

  @@index([userId])
  @@index([userId, type])
}

model CreditCardTerms {
  accountId          String   @id
  statementDay       Int      @db.SmallInt
  paymentDueDay      Int      @db.SmallInt
  interestRateAnnual Decimal? @db.Decimal(9, 4)
  minPaymentRule     String?
  gracePeriodDays    Int?
  updatedAt          DateTime @updatedAt

  account Account @relation(fields: [accountId], references: [id], onDelete: Cascade)
}

model Category {
  id        String   @id @default(uuid())
  userId    String? // null => default global
  parentId  String?
  name      String
  isDefault Boolean  @default(false)
  sortOrder Int?
  createdAt DateTime @default(now())

  user          User?             @relation(fields: [userId], references: [id], onDelete: SetNull)
  parent        Category?         @relation("category_to_self", fields: [parentId], references: [id], onDelete: SetNull)
  children      Category[]        @relation("category_to_self")
  transactions  Transaction[]
  budgetCaps    BUDGET_CATEGORY[]
  RecurringRule RecurringRule[]

  @@index([userId])
  @@index([parentId])
}

model Transaction {
  id                  String            @id @default(uuid())
  userId              String
  accountId           String
  categoryId          String?
  type                TransactionType
  amount              Decimal           @db.Decimal(18, 2)
  currency            String            @db.VarChar(3)
  txnDate             DateTime          @db.Date
  description         String?
  merchantName        String?
  isPending           Boolean           @default(false)
  isRecurringInstance Boolean           @default(false)
  source              TransactionSource
  externalId          String?           @unique
  createdAt           DateTime          @default(now())
  updatedAt           DateTime          @updatedAt

  user     User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  account  Account   @relation(fields: [accountId], references: [id], onDelete: Restrict)
  category Category? @relation(fields: [categoryId], references: [id], onDelete: SetNull)

  // Relaciones inversas para Transfer (1–1)
  transferFrom Transfer? @relation("transfer_from")
  transferTo   Transfer? @relation("transfer_to")

  attachments       Attachment[]
  debtPayment       DebtPayment?
  goalContributions GoalContribution[] // <-- ahora 1–N (fix)
  transactionTags   TransactionTag[]
  importedMatches   ImportedTransaction[] @relation("imported_matched")

  @@index([userId, txnDate(sort: Desc)])
  @@index([userId, accountId, txnDate(sort: Desc)])
  @@index([source])
}

model Transfer {
  id        String   @id @default(uuid())
  fromTxnId String   @unique
  toTxnId   String   @unique
  amount    Decimal  @db.Decimal(18, 2)
  createdAt DateTime @default(now())

  fromTxn Transaction @relation("transfer_from", fields: [fromTxnId], references: [id], onDelete: Restrict)
  toTxn   Transaction @relation("transfer_to", fields: [toTxnId], references: [id], onDelete: Restrict)
}

model Attachment {
  id            String   @id @default(uuid())
  transactionId String
  fileUrl       String
  fileType      String
  fileSize      Int?
  extra         Json?
  uploadedAt    DateTime @default(now())

  transaction Transaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)

  @@index([transactionId])
}

model RecurringRule {
  id                String             @id @default(uuid())
  userId            String
  defaultAccountId  String?
  defaultCategoryId String?
  frequency         RecurringFrequency
  interval          Int                @db.SmallInt
  byday             String?
  startDate         DateTime           @db.Date
  endDate           DateTime?          @db.Date
  amount            Decimal            @db.Decimal(18, 2)
  merchantName      String?
  autoConfirm       Boolean            @default(false)
  nextOccurrence    DateTime?
  templateOverrides Json?
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt

  user     User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  account  Account?  @relation(fields: [defaultAccountId], references: [id], onDelete: SetNull)
  category Category? @relation(fields: [defaultCategoryId], references: [id], onDelete: SetNull)
}

model Budget {
  id          String   @id @default(uuid())
  userId      String
  year        Int      @db.SmallInt
  month       Int      @db.SmallInt
  currency    String   @db.VarChar(3)
  amountTotal Decimal? @db.Decimal(18, 2)
  createdAt   DateTime @default(now())

  user       User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  categories BUDGET_CATEGORY[]

  @@unique([userId, year, month])
  @@index([userId])
}

model BUDGET_CATEGORY {
  id         String  @id @default(uuid())
  budgetId   String
  categoryId String
  capAmount  Decimal @db.Decimal(18, 2)

  budget   Budget   @relation(fields: [budgetId], references: [id], onDelete: Cascade)
  category Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)

  @@unique([budgetId, categoryId])
  @@index([categoryId])
}

model Goal {
  id            String    @id @default(uuid())
  userId        String
  name          String
  targetAmount  Decimal   @db.Decimal(18, 2)
  dueDate       DateTime? @db.Date
  currentAmount Decimal   @default(0) @db.Decimal(18, 2)
  currency      String    @db.VarChar(3)
  createdAt     DateTime  @default(now())

  user          User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  contributions GoalContribution[]
}

model GoalContribution {
  id            String   @id @default(uuid())
  goalId        String
  transactionId String? // 1–N: una transacción puede aportar a varias metas
  amount        Decimal  @db.Decimal(18, 2)
  date          DateTime @db.Date

  goal        Goal         @relation(fields: [goalId], references: [id], onDelete: Cascade)
  transaction Transaction? @relation(fields: [transactionId], references: [id], onDelete: SetNull)

  @@index([goalId, date])
  @@index([transactionId])
}

model Debt {
  id                 String    @id @default(uuid())
  userId             String
  name               String
  kind               DebtKind
  principal          Decimal   @db.Decimal(18, 2)
  interestRateAnnual Decimal?  @db.Decimal(9, 4)
  minPaymentAmount   Decimal?  @db.Decimal(18, 2)
  startDate          DateTime? @db.Date
  dueDate            DateTime? @db.Date
  linkedAccountId    String?
  createdAt          DateTime  @default(now())

  user          User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  payments      DebtPayment[]
  linkedAccount Account?      @relation("debt_linked_account", fields: [linkedAccountId], references: [id], onDelete: SetNull)

  @@index([userId])
}

model DebtPayment {
  id            String   @id @default(uuid())
  debtId        String
  transactionId String
  amount        Decimal  @db.Decimal(18, 2)
  date          DateTime @db.Date

  debt        Debt        @relation(fields: [debtId], references: [id], onDelete: Cascade)
  transaction Transaction @relation(fields: [transactionId], references: [id], onDelete: Restrict)

  @@unique([transactionId])
  @@index([debtId, date])
}

model Notification {
  id                String             @id @default(uuid())
  userId            String
  type              NotificationType
  title             String
  message           String
  status            NotificationStatus @default(scheduled)
  scheduledAt       DateTime?
  sentAt            DateTime?
  relatedEntityId   String?
  relatedEntityType String?
  createdAt         DateTime           @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, status])
}

model BankConnection {
  id             String               @id @default(uuid())
  userId         String
  provider       BankProvider
  providerItemId String               @unique
  status         BankConnectionStatus
  createdAt      DateTime             @default(now())
  updatedAt      DateTime             @updatedAt

  user           User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  linkedAccounts LinkedAccount[]
}

model LinkedAccount {
  id                String  @id @default(uuid())
  bankConnectionId  String
  accountId         String
  providerAccountId String  @unique
  mask              String?
  officialName      String?
  type              String?
  currency          String? @db.VarChar(3)

  bankConnection BankConnection        @relation(fields: [bankConnectionId], references: [id], onDelete: Cascade)
  account        Account               @relation(fields: [accountId], references: [id], onDelete: Cascade)
  importedTxs    ImportedTransaction[]

  @@index([bankConnectionId])
  @@index([accountId])
}

model ImportedTransaction {
  id                   String   @id @default(uuid())
  linkedAccountId      String
  providerTxnId        String   @unique
  amount               Decimal  @db.Decimal(18, 2)
  currency             String   @db.VarChar(3)
  date                 DateTime @db.Date
  merchant             String?
  raw                  Json?
  matchedTransactionId String?
  importedAt           DateTime @default(now())

  linkedAccount      LinkedAccount @relation(fields: [linkedAccountId], references: [id], onDelete: Cascade)
  matchedTransaction Transaction?  @relation("imported_matched", fields: [matchedTransactionId], references: [id], onDelete: SetNull)

  @@index([linkedAccountId, date])
}

model ReconciliationSession {
  id        String    @id @default(uuid())
  userId    String
  startedAt DateTime  @default(now())
  endedAt   DateTime?
  status    String    @default("open") // "open|closed"

  user  User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  items ReconciliationItem[]
}

model ReconciliationItem {
  id          String                 @id @default(uuid())
  sessionId   String
  accountId   String
  itemType    ReconciliationItemType
  referenceId String
  state       ReconciliationState
  details     Json?

  session ReconciliationSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  account Account               @relation(fields: [accountId], references: [id], onDelete: Cascade)

  @@index([sessionId])
  @@index([accountId])
}

model Tag {
  id        String   @id @default(uuid())
  userId    String
  name      String
  createdAt DateTime @default(now())

  user            User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  transactionTags TransactionTag[]

  @@unique([userId, name])
  @@index([userId])
}

model TransactionTag {
  transactionId String
  tagId         String

  transaction Transaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)
  tag         Tag         @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([transactionId, tagId])
}
